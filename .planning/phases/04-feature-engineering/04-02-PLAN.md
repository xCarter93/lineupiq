---
phase: 04-feature-engineering
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [packages/backend/src/lineupiq/features/opponent_features.py, packages/backend/tests/test_opponent_features.py, packages/backend/src/lineupiq/features/__init__.py]
autonomous: true
---

<objective>
Create opponent defensive strength features module.

Purpose: Opponent quality significantly impacts player performance. A WR facing a weak secondary will likely outperform expectations, while one facing a top defense will underperform. Defensive strength metrics capture this matchup context.
Output: opponent_features.py module with defensive strength rankings ready for ML consumption.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context - data processing pipeline
@.planning/phases/03-data-processing/03-03-SUMMARY.md

# Existing data module structure
@packages/backend/src/lineupiq/data/__init__.py
@packages/backend/src/lineupiq/data/processing.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create opponent_features module with defensive strength metrics</name>
  <files>packages/backend/src/lineupiq/features/opponent_features.py, packages/backend/src/lineupiq/features/__init__.py</files>
  <action>
Create opponent_features.py module with:

1. `compute_defensive_stats(df: pl.DataFrame) -> pl.DataFrame`
   - Aggregate stats ALLOWED by each defense (i.e., stats scored AGAINST each team)
   - Group by: opponent (the team being scored against), season, week
   - Compute per-week: total passing_yards allowed, rushing_yards allowed, receiving_yards allowed, TDs allowed
   - This creates a "what defenses give up" view

2. `compute_defensive_rankings(defensive_df: pl.DataFrame) -> pl.DataFrame`
   - From defensive_stats, compute season-to-date rankings for each team
   - Use cumulative sum up to but NOT including current week (avoid leakage)
   - Rank 1 = best defense (allows fewest yards), Rank 32 = worst
   - Output columns:
     - opp_pass_yards_allowed_rank (1-32)
     - opp_rush_yards_allowed_rank (1-32)
     - opp_total_yards_allowed_rank (1-32)

3. `add_opponent_strength(df: pl.DataFrame) -> pl.DataFrame`
   - Main entry point that orchestrates:
     a. Compute defensive stats from player data
     b. Compute rankings
     c. Join rankings back to player data on opponent + season + week
   - Result: Each player row has opponent defensive rankings attached

4. Normalize rankings to 0-1 scale: `(rank - 1) / 31`
   - 0 = best defense (hardest matchup)
   - 1 = worst defense (easiest matchup)
   - Column: opp_pass_defense_strength, opp_rush_defense_strength

Important: Use week-1 data for rankings to avoid data leakage. Week 3's opponent strength should be computed from weeks 1-2 only.

Update features/__init__.py to export add_opponent_strength.
  </action>
  <verify>
```bash
cd packages/backend && uv run python -c "
from lineupiq.features import add_opponent_strength
from lineupiq.data import process_player_stats
import polars as pl

# Load test data
df = process_player_stats([2024])

# Add opponent strength
result = add_opponent_strength(df)

# Verify new columns exist
assert 'opp_pass_defense_strength' in result.columns
assert 'opp_rush_defense_strength' in result.columns
print(f'Opponent features added: {len(result)} rows, {len(result.columns)} columns')

# Check values are in expected range
strength = result.select('opp_pass_defense_strength').to_series()
non_null = strength.drop_nulls()
if len(non_null) > 0:
    assert non_null.min() >= 0, 'Min should be >= 0'
    assert non_null.max() <= 1, 'Max should be <= 1'
    print(f'opp_pass_defense_strength range: {non_null.min():.2f} - {non_null.max():.2f}')
"
```
  </verify>
  <done>
- opponent_features.py exists with add_opponent_strength function
- Function computes defensive rankings without data leakage
- Rankings normalized to 0-1 scale
- Features module exports add_opponent_strength
- Verification script runs without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for opponent features</name>
  <files>packages/backend/tests/test_opponent_features.py</files>
  <action>
Create test_opponent_features.py with tests for:

1. `test_defensive_stats_aggregation()` - Verify stats are summed by opponent correctly
   - Create synthetic data where team A plays against team B
   - Team B's defense should have stats from what A scored against them

2. `test_defensive_rankings_ordering()` - Verify ranking order is correct
   - Team allowing fewest yards = rank 1
   - Team allowing most yards = rank 32 (or N for N teams in test)

3. `test_no_data_leakage()` - Critical: verify week N rankings only use weeks < N
   - Create 3 weeks of data
   - Week 3 rankings should only reflect weeks 1-2
   - Verify by checking a team whose week 3 stats would change their ranking

4. `test_opponent_strength_normalization()` - Verify 0-1 normalization
   - Best defense (rank 1) should have strength near 0
   - Worst defense (rank 32) should have strength near 1

5. `test_opponent_join()` - Verify opponent strength joins correctly to player data
   - Player on team A vs opponent B should get B's defensive rankings

Use pytest fixtures with controlled synthetic data for deterministic tests.
  </action>
  <verify>
```bash
cd packages/backend && uv run pytest tests/test_opponent_features.py -v
```
  </verify>
  <done>
- test_opponent_features.py exists with 5+ tests
- All tests pass
- Tests verify no data leakage in ranking computation
- Tests verify correct normalization and join logic
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd packages/backend && uv run pytest tests/test_opponent_features.py -v` passes all tests
- [ ] `cd packages/backend && uv run python -c "from lineupiq.features import add_opponent_strength"` imports successfully
- [ ] Opponent strength values are in 0-1 range
- [ ] No data leakage (rankings computed from prior weeks only)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Opponent strength module computes defensive rankings
- Rankings are normalized to 0-1 scale
- No data leakage in ranking computation
- Tests verify correctness
</success_criteria>

<output>
After completion, create `.planning/phases/04-feature-engineering/04-02-SUMMARY.md`
</output>
