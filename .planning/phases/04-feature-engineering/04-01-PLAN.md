---
phase: 04-feature-engineering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [packages/backend/src/lineupiq/features/rolling_stats.py, packages/backend/tests/test_rolling_stats.py, packages/backend/src/lineupiq/features/__init__.py]
autonomous: true
---

<objective>
Create rolling window statistics module for player performance features.

Purpose: Rolling 3-week averages smooth out single-game variance and capture recent form, which is more predictive than career averages or single-game stats.
Output: rolling_stats.py module with position-specific rolling features ready for ML consumption.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context - data processing pipeline
@.planning/phases/03-data-processing/03-03-SUMMARY.md

# Existing data module structure
@packages/backend/src/lineupiq/data/__init__.py
@packages/backend/src/lineupiq/data/processing.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rolling_stats module with position-specific rolling averages</name>
  <files>packages/backend/src/lineupiq/features/rolling_stats.py, packages/backend/src/lineupiq/features/__init__.py</files>
  <action>
Create new features/ directory and rolling_stats.py module with:

1. `compute_rolling_stats(df: pl.DataFrame, window: int = 3) -> pl.DataFrame`
   - Input: Processed player stats from process_player_stats()
   - Compute rolling averages using Polars `rolling_mean()` over `window` games
   - Group by player_id, compute rolling means within each player's game history
   - Sort by player_id, season, week before computing to ensure correct ordering

2. Rolling features to compute (suffix with `_roll{window}`):
   - Passing: passing_yards, passing_tds, interceptions
   - Rushing: rushing_yards, rushing_tds, carries
   - Receiving: receiving_yards, receiving_tds, receptions

3. Use Polars over() with partition_by for efficient grouped rolling:
   ```python
   df.with_columns([
       pl.col("passing_yards")
         .rolling_mean(window_size=window, min_periods=1)
         .over("player_id")
         .alias(f"passing_yards_roll{window}")
   ])
   ```

4. Use min_periods=1 to handle players with fewer than `window` games (early season)

5. Create features/__init__.py exporting compute_rolling_stats

Why min_periods=1: New players or early-season games need predictions too. Using actual games played is more accurate than filling with zeros.

Why group by player_id: Rolling stats must be computed per-player, not across all players. A player's week 3 rolling avg should only include their weeks 1-2.
  </action>
  <verify>
```bash
cd packages/backend && uv run python -c "
from lineupiq.features import compute_rolling_stats
from lineupiq.data import process_player_stats
import polars as pl

# Load test data
df = process_player_stats([2024])

# Compute rolling stats
result = compute_rolling_stats(df, window=3)

# Verify new columns exist
assert 'passing_yards_roll3' in result.columns
assert 'rushing_yards_roll3' in result.columns
assert 'receiving_yards_roll3' in result.columns
print(f'Rolling stats computed: {len(result)} rows, {len(result.columns)} columns')
print('New rolling columns:', [c for c in result.columns if '_roll' in c])
"
```
  </verify>
  <done>
- rolling_stats.py exists with compute_rolling_stats function
- Function computes rolling averages for passing/rushing/receiving stats
- Features module exports compute_rolling_stats
- Verification script runs without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for rolling stats</name>
  <files>packages/backend/tests/test_rolling_stats.py</files>
  <action>
Create test_rolling_stats.py with tests for:

1. `test_rolling_stats_basic()` - Verify rolling columns created with correct naming
2. `test_rolling_stats_calculation()` - Verify rolling math is correct
   - Create synthetic data with known values
   - Player with weeks 1,2,3 having passing_yards [100, 200, 300]
   - Week 3 rolling avg should be 200 (mean of 100,200,300)
   - Week 2 rolling avg should be 150 (mean of 100,200)
3. `test_rolling_stats_per_player()` - Verify rolling is computed per player, not globally
   - Create two players with different stats
   - Verify each player's rolling only uses their own history
4. `test_rolling_stats_min_periods()` - Verify min_periods=1 works for early season
   - Week 1 should have rolling avg equal to week 1 value (only 1 period available)
5. `test_rolling_stats_different_window()` - Verify window parameter works (e.g., window=5)

Use pytest fixtures for synthetic test data to keep tests fast and isolated.
  </action>
  <verify>
```bash
cd packages/backend && uv run pytest tests/test_rolling_stats.py -v
```
  </verify>
  <done>
- test_rolling_stats.py exists with 5+ tests
- All tests pass
- Tests verify rolling calculation correctness and per-player grouping
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd packages/backend && uv run pytest tests/test_rolling_stats.py -v` passes all tests
- [ ] `cd packages/backend && uv run python -c "from lineupiq.features import compute_rolling_stats"` imports successfully
- [ ] Rolling columns have correct naming pattern (stat_roll3)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Rolling stats module computes 3-week rolling averages for key stats
- Per-player grouping ensures correct rolling window computation
- Tests verify correctness of rolling calculations
</success_criteria>

<output>
After completion, create `.planning/phases/04-feature-engineering/04-01-SUMMARY.md`
</output>
